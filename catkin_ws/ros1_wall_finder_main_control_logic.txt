#!/usr/bin/env python
import rospy
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
from ros_wall_following.srv import FindWall, FindWallResponse
import math
import numpy as np

# Global variables for ROS1 simple structure
scan_data = None
ranges_data = None
cmd_vel_pub = None

def scan_callback(msg):
    """Callback for laser scan data"""
    global scan_data, ranges_data
    scan_data = msg
    
    # Convert ranges to numpy array and filter invalid readings
    ranges = np.array(msg.ranges)
    ranges_data = np.where(np.isfinite(ranges), ranges, 10.0)

    # Debug print laser configuration once
    if not hasattr(scan_callback, "_printed_debug"):
        scan_callback._printed_debug = True
        rospy.loginfo("FIRST LASER DATA RECEIVED!")
        rospy.loginfo("LaserScan config: angle_min=%.2f rad, angle_max=%.2f rad, "
                      "angle_increment=%.4f rad" % (msg.angle_min, msg.angle_max, msg.angle_increment))
        angle_range = (msg.angle_max - msg.angle_min) * 180.0 / math.pi
        rospy.loginfo("360° Laser: %d points, %.1f° coverage" % (len(ranges_data), angle_range))
        
        # Calculate and log key indices for verification
        front_idx = int((0.0 - msg.angle_min) / msg.angle_increment)
        right_idx = int((math.pi/2 - msg.angle_min) / msg.angle_increment)
        rospy.loginfo("Key indices: front=%d, right=%d" % (front_idx, right_idx))
        rospy.loginfo("Laser data is now available for service calls")
    
    # Print periodic status (every 100 messages to avoid spam)
    if not hasattr(scan_callback, "_msg_count"):
        scan_callback._msg_count = 0
    scan_callback._msg_count += 1
    
    if scan_callback._msg_count % 100 == 0:
        rospy.loginfo("Laser scan still active (message #%d)" % scan_callback._msg_count)


def analyze_sectors_for_wall_finding():
    """
    Sector-based laser analysis for wall finding (ROS1 version)
    
    Divides 360° laser scan into meaningful sectors to find nearest wall.
    Uses actual laser parameters for correct geometry calculations.
    
    Returns:
        dict: Analysis results with closest sector information
    """
    global ranges_data, scan_data
    if ranges_data is None or scan_data is None:
        return None
    
    rospy.loginfo("Conducting sector-based 360° laser analysis...")
    
    # Calculate sector indices based on actual laser geometry
    def angle_to_index(angle_deg):
        angle_rad = angle_deg * math.pi / 180.0
        idx = int((angle_rad - scan_data.angle_min) / scan_data.angle_increment)
        return max(0, min(idx, len(ranges_data) - 1))
    
    # Define sectors for 360° laser with correct geometry
    sectors = {
        "Right": (angle_to_index(70), angle_to_index(110)),           # Right side wall (90° ± 20°)
        "Front_Right": (angle_to_index(20), angle_to_index(70)),      # Front-right area
        "Front_Center": (angle_to_index(-20), angle_to_index(20)),    # Direct front (0° ± 20°)
        "Front_Left": (angle_to_index(-70), angle_to_index(-20)),     # Front-left area  
        "Left": (angle_to_index(-110), angle_to_index(-70)),          # Left side (-90° ± 20°)
        "Rear": (angle_to_index(160), angle_to_index(-160)),          # Rear area (±180° ± 20°)
    }
    
    # Calculate minimum distance for each sector
    min_distances = {}
    sector_stats = {}
    
    for sector_name, (start_idx, end_idx) in sectors.items():
        # Handle wrap-around for rear sector
        if start_idx > end_idx:  # Wrap-around case (rear sector)
            # Split into two parts: [start_idx, len-1] and [0, end_idx]
            sector_ranges_1 = ranges_data[start_idx:]
            sector_ranges_2 = ranges_data[:end_idx + 1]
            sector_ranges = np.concatenate([sector_ranges_1, sector_ranges_2])
            
            # Find minimum and adjust index with distance filtering
            if len(sector_ranges) > 0:
                # Filter out very close readings and invalid readings
                valid_ranges = sector_ranges[np.isfinite(sector_ranges) & 
                                           (sector_ranges > 0.1) &  # Minimum 10cm
                                           (sector_ranges < 10.0)]  # Maximum 10m
                if len(valid_ranges) > 0:
                    min_val = np.min(valid_ranges)
                    min_idx_in_concat = np.argmin(sector_ranges)
                    if min_idx_in_concat < len(sector_ranges_1):
                        min_idx_in_sector = start_idx + min_idx_in_concat
                    else:
                        min_idx_in_sector = min_idx_in_concat - len(sector_ranges_1)
                else:
                    min_val = float('inf')
                    min_idx_in_sector = start_idx
            else:
                min_val = float('inf')
                min_idx_in_sector = start_idx
        else:
            # Normal case
            start_idx = max(0, start_idx)
            end_idx = min(len(ranges_data) - 1, end_idx)
            
            if start_idx <= end_idx:
                sector_ranges = ranges_data[start_idx:end_idx + 1]
                # Filter out readings that are too close (likely robot parts) or invalid
                valid_sector_ranges = sector_ranges[np.isfinite(sector_ranges) & 
                                                   (sector_ranges > 0.1) &  # Minimum 10cm distance
                                                   (sector_ranges < 10.0)]  # Maximum 10m distance
                
                if len(valid_sector_ranges) > 0:
                    min_val = np.min(valid_sector_ranges)
                    min_idx_in_sector = np.argmin(sector_ranges) + start_idx
                else:
                    min_val = float('inf')
                    min_idx_in_sector = start_idx
            else:
                min_val = float('inf')
                min_idx_in_sector = start_idx
        
        if min_val != float('inf'):
            min_distances[sector_name] = min_val
            # Calculate actual angle using laser parameters
            min_angle_rad = scan_data.angle_min + min_idx_in_sector * scan_data.angle_increment
            min_angle_deg = min_angle_rad * 180.0 / math.pi
            
            sector_stats[sector_name] = {
                'min_distance': min_val,
                'min_index': min_idx_in_sector,
                'min_angle': min_angle_deg,
                'start_idx': start_idx,
                'end_idx': end_idx
            }
            sector_stats[sector_name] = {
                'min_distance': min_val,
                'min_index': min_idx_in_sector,
                'min_angle': min_angle_deg,
                'start_idx': start_idx,
                'end_idx': end_idx
            }
        else:
            min_distances[sector_name] = float('inf')
            sector_stats[sector_name] = None
    
    # Find the sector with absolute minimum distance
    valid_sectors = {k: v for k, v in min_distances.items() if v != float('inf')}
    
    if valid_sectors:
        closest_sector = min(valid_sectors, key=valid_sectors.get)
        closest_distance = valid_sectors[closest_sector]
        closest_sector_stats = sector_stats[closest_sector]
    else:
        rospy.logerr("No valid sectors found!")
        return None
    
    # Calculate rotation needed to align front with closest obstacle
    # Calculate front center index dynamically based on laser parameters
    front_center_idx = int((0.0 - scan_data.angle_min) / scan_data.angle_increment)
    
    if closest_sector_stats and closest_sector_stats['min_index'] is not None:
        target_idx = closest_sector_stats['min_index']
        angular_diff = target_idx - front_center_idx
        
        # Determine rotation direction
        if abs(angular_diff) <= 5:  # Allow tolerance of ±5 indices (≈±2.5°)
            rotation_needed = "NONE - Already aligned (within tolerance)"
            rotation_direction = 0
        elif angular_diff > 0:
            rotation_needed = "COUNTERCLOCKWISE by %d indices" % angular_diff
            rotation_direction = 1
        else:
            rotation_needed = "CLOCKWISE by %d indices" % abs(angular_diff)
            rotation_direction = -1
    else:
        rotation_needed = "UNKNOWN - No valid target"
        rotation_direction = 0
        angular_diff = 0
    
    # Print analysis results
    rospy.loginfo("=" * 60)
    rospy.loginfo("SECTOR-BASED 360° LASER ANALYSIS RESULTS")
    rospy.loginfo("=" * 60)
    rospy.loginfo("Closest obstacle in sector: %s" % closest_sector)
    rospy.loginfo("Distance: %.3fm" % closest_distance)
    if closest_sector_stats:
        rospy.loginfo("Index: %d, Angle: %.1f°" % (closest_sector_stats['min_index'], closest_sector_stats['min_angle']))
    rospy.loginfo("Rotation needed: %s" % rotation_needed)
    rospy.loginfo("=" * 60)
    
    return {
        'closest_sector': closest_sector,
        'closest_distance': closest_distance,
        'closest_sector_stats': closest_sector_stats,
        'angular_difference': angular_diff,
        'rotation_direction': rotation_direction,
        'target_achieved': (abs(angular_diff) <= 5)  # Allow ±5 indices tolerance (≈±2.5°)
    }


def handle_find_wall(req):
    """Service callback function - follows the simple ROS1 pattern"""
    global scan_data, ranges_data, cmd_vel_pub
    
    rospy.loginfo("=== FIND WALL SERVICE CALLED ===")
    
    # Check if scan data is already available
    if scan_data is not None:
        rospy.loginfo("Laser scan data is available - proceeding immediately")
    else:
        rospy.loginfo("Waiting for laser scan data on /scan topic...")
    
    # Wait for scan data with timeout and better logging
    wait_start = rospy.Time.now()
    timeout_duration = 10.0  # Increased to 10 seconds
    
    while scan_data is None:
        elapsed = (rospy.Time.now() - wait_start).to_sec()
        
        if elapsed > timeout_duration:
            rospy.logerr("TIMEOUT: No laser scan data received after %.1f seconds" % timeout_duration)
            rospy.logerr("Check if laser is publishing on /scan topic:")
            rospy.logerr("  rostopic list | grep scan")
            rospy.logerr("  rostopic hz /scan")
            return FindWallResponse(wallfound=False)
            
        # Print waiting message every 2 seconds
        if int(elapsed) % 2 == 0 and elapsed > 0:
            rospy.loginfo("Still waiting for laser data... (%.1f/%.1f seconds)" % (elapsed, timeout_duration))
            
        rospy.sleep(0.1)

    rospy.loginfo("Laser scan data received! Starting wall finding sequence...")
    
    rate = rospy.Rate(10)
    twist = Twist()
    
    rospy.loginfo("=== STARTING WALL-FINDING SEQUENCE (Sector-Based Analysis) ===")
    
    # ==================== STEP 1: FACE NEAREST WALL ====================
    rospy.loginfo("Step 1: Rotating to face nearest wall using sector analysis")
    
    # Stop robot for stable analysis
    twist = Twist()
    cmd_vel_pub.publish(twist)
    rospy.sleep(1.0)
    
    # Perform sector-based analysis
    analysis_result = analyze_sectors_for_wall_finding()
    
    if analysis_result is None:
        rospy.logerr("Failed to analyze laser data - aborting wall finding")
        return FindWallResponse(wallfound=False)
    
    # Check if robot is already aligned with the nearest wall
    if analysis_result['target_achieved']:
        rospy.loginfo("Robot is already facing the nearest wall - proceeding to Step 2")
    else:
        # Execute rotation based on sector analysis
        target_index = analysis_result['closest_sector_stats']['min_index']
        target_angle = analysis_result['closest_sector_stats']['min_angle']
        closest_distance = analysis_result['closest_distance']
        closest_sector = analysis_result['closest_sector']
        rotation_direction_sign = analysis_result['rotation_direction']
        
        rospy.loginfo("EXECUTING ROTATION (Sector-Based Analysis):")
        rospy.loginfo("  Target: Index %d (%.1f°)" % (target_index, target_angle))
        rospy.loginfo("  Closest Sector: %s" % closest_sector)
        rospy.loginfo("  Distance to target: %.3fm" % closest_distance)
        
        # Rotate until front is aligned with nearest wall (with timeout)
        rotation_start = rospy.Time.now()
        rotation_timeout = 15.0  # 15 seconds timeout
        stuck_counter = 0  # Counter to detect if robot is stuck
        last_angular_diff = None
        
        while not rospy.is_shutdown():
            # Check timeout
            if (rospy.Time.now() - rotation_start).to_sec() > rotation_timeout:
                rospy.logwarn("Rotation timeout reached - proceeding to next step")
                break
            
            # Get fresh sector analysis
            current_analysis = analyze_sectors_for_wall_finding()
            if current_analysis is None:
                rospy.logwarn("Lost laser data during rotation - continuing")
                break
            
            current_angular_diff = current_analysis['angular_difference']
            
            # Check if target is achieved
            if current_analysis['target_achieved']:
                rospy.loginfo("TARGET ACHIEVED! Front is now aligned with nearest wall (diff: %d indices)" % current_angular_diff)
                break
            
            # Detect if robot is stuck (angular difference not changing)
            if last_angular_diff is not None and abs(current_angular_diff - last_angular_diff) <= 1:
                stuck_counter += 1
                if stuck_counter > 20:  # If stuck for 2 seconds at 10Hz
                    rospy.logwarn("Robot appears stuck - angular difference not changing. Proceeding to next step.")
                    break
            else:
                stuck_counter = 0
            
            last_angular_diff = current_angular_diff
            
            # Log progress
            closest_sector = current_analysis['closest_sector']
            closest_distance = current_analysis['closest_distance']
            rospy.loginfo("Still rotating... Closest: %s sector at %.3fm, diff: %d indices" % 
                        (closest_sector, closest_distance, current_angular_diff))
            
            # Send rotation command
            twist.angular.z = rotation_direction_sign * 0.3
            twist.linear.x = 0.0
            cmd_vel_pub.publish(twist)
            rate.sleep()
    
    # Stop rotation
    twist = Twist()
    cmd_vel_pub.publish(twist)
    rospy.sleep(0.5)

    # ==================== STEP 2: APPROACH WALL ====================
    rospy.loginfo("Step 2: Moving forward to approach wall")
    
    # Calculate front index dynamically based on laser parameters
    front_idx = int((0.0 - scan_data.angle_min) / scan_data.angle_increment)
    approach_start = rospy.Time.now()
    approach_timeout = 20.0  # 20 seconds timeout
    
    while not rospy.is_shutdown():
        # Check timeout
        if (rospy.Time.now() - approach_start).to_sec() > approach_timeout:
            rospy.logwarn("Wall approach timeout reached - proceeding to next step")
            break
            
        ranges = list(scan_data.ranges)
        front_dist = ranges[front_idx] if (front_idx < len(ranges) and 
                                         ranges[front_idx] > 0 and 
                                         ranges[front_idx] != float('inf') and 
                                         not math.isnan(ranges[front_idx])) else float('inf')
        
        if front_dist == float('inf'):
            rospy.logwarn("Invalid front distance reading - continuing anyway")
            rospy.sleep(0.5)
            continue
            
        rospy.loginfo("Front distance: %.2fm" % front_dist)
        
        if front_dist <= 0.3:
            rospy.loginfo("Reached 0.3m from wall")
            break
            
        # Safety check - don't get too close
        if front_dist <= 0.15:
            rospy.logwarn("Too close to wall! Stopping approach")
            break
            
        twist.linear.x = 0.2
        twist.angular.z = 0.0
        cmd_vel_pub.publish(twist)
        rate.sleep()
        
    # Stop movement
    twist = Twist()
    cmd_vel_pub.publish(twist)
    rospy.sleep(0.5)

    # ==================== STEP 3: ALIGN WALL ON RIGHT SIDE ====================
    rospy.loginfo("Step 3: Rotating to align wall on right side")
    
    # Calculate right side index dynamically (+90° from front)
    right_angle = math.pi / 2  # +90° in radians
    right_idx = int((right_angle - scan_data.angle_min) / scan_data.angle_increment)
    alignment_start = rospy.Time.now()
    alignment_timeout = 15.0  # 15 seconds timeout
    
    while not rospy.is_shutdown():
        # Check timeout
        if (rospy.Time.now() - alignment_start).to_sec() > alignment_timeout:
            rospy.logwarn("Right side alignment timeout reached - completing service")
            break
            
        ranges = list(scan_data.ranges)
        
        # Get right side distance
        right_dist = ranges[right_idx] if (ranges[right_idx] > 0 and 
                                         ranges[right_idx] != float('inf') and 
                                         not math.isnan(ranges[right_idx])) else float('inf')
            
        # Get front distance
        front_dist = ranges[front_idx] if (front_idx < len(ranges) and 
                                         ranges[front_idx] > 0 and 
                                         ranges[front_idx] != float('inf') and 
                                         not math.isnan(ranges[front_idx])) else float('inf')
        
        rospy.loginfo("Right side distance: %.2fm, Front distance: %.2fm" % (right_dist, front_dist))
        
        # Find the current closest ray to determine if right side is pointing at the wall
        filtered = [(i, r) for i, r in enumerate(ranges) 
                   if r > 0 and r != float('inf') and not math.isnan(r)]
        
        if not filtered:
            rospy.logwarn("No valid laser readings - completing service anyway")
            break
            
        min_idx, min_dist = min(filtered, key=lambda x: x[1])
        
        # Check if right side is now pointing at the wall (is the closest or very close to closest)
        if right_idx == min_idx or abs(right_dist - min_dist) < 0.1:
            rospy.loginfo("Right side now aligned with wall (distance: %.2fm)" % right_dist)
            break
        
        # Additional success condition - if right side distance is reasonable and stable
        if right_dist < 1.0 and right_dist > 0.1:
            rospy.loginfo("Right side alignment achieved (distance: %.2fm)" % right_dist)
            break
        
        # Rotate left to bring right side toward wall
        twist.linear.x = 0.0
        twist.angular.z = 0.3
        cmd_vel_pub.publish(twist)
        rate.sleep()

    # Stop rotation
    twist = Twist()
    cmd_vel_pub.publish(twist)

    rospy.loginfo("Wall found and aligned using sector-based analysis.")
    return FindWallResponse(wallfound=True)

# Main execution - simple ROS1 pattern like your example
if __name__ == '__main__':
    try:
        # Initialize ROS node
        rospy.init_node('find_wall_server')
        rospy.loginfo("ROS node 'find_wall_server' initialized")
        
        # Set up global publisher
        cmd_vel_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=1)
        rospy.loginfo("Publisher to /cmd_vel created")
        
        # Set up subscriber
        rospy.Subscriber('/scan', LaserScan, scan_callback)
        rospy.loginfo("Subscriber to /scan created - waiting for laser data...")
        
        # Create the service - using the simple pattern like your example
        find_wall_service = rospy.Service('find_wall', FindWall, handle_find_wall)
        rospy.loginfo("Service /find_wall created and ready")
        
        rospy.loginfo("Find_wall service ready with sector-based analysis for 360° laser (Simple ROS1 Pattern)")
        rospy.loginfo("Waiting for laser scan data and service calls...")
        rospy.loginfo("To test: rosservice call /find_wall")
        
        # Keep the service running - like your example
        rospy.spin()
        
    except rospy.ROSInterruptException:
        rospy.loginfo("Shutting down find_wall_server")
        pass
